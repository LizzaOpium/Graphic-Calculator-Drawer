import matplotlib.pyplot as plt
import numpy as np
import re
import math

def beautify_axes(ax):
    # Оси проходят через (0, 0)
    ax.spines['left'].set_position('zero')
    ax.spines['bottom'].set_position('zero')
    ax.spines['right'].set_color('none')
    ax.spines['top'].set_color('none')

    # Стрелки на концах осей
    ax.plot(1, 0, ">k", transform=ax.get_yaxis_transform(), clip_on=False)
    ax.plot(0, 1, "^k", transform=ax.get_xaxis_transform(), clip_on=False)

    # Подписи
    ax.text(1.02, 0, 'x', transform=ax.get_yaxis_transform(),
            ha='left', va='center', fontsize=12)
    ax.text(0, 1.02, 'y', transform=ax.get_xaxis_transform(),
            ha='center', va='bottom', fontsize=12)

    # Сетка
    ax.grid(True, which='both', alpha=0.3, linewidth=0.7)

    # Деления по обеим осям
    ax.set_xticks(np.arange(-10, 11, 1))
    ax.set_yticks(np.arange(-10, 11, 1))

    # Ограничения
    ax.set_xlim(-10, 10)
    ax.set_ylim(-10, 10)

    # Масштаб одинаковый
    ax.set_aspect('equal', 'box')


def has_parameter_p(equation):
    return bool(re.search(r'\bp\b', equation))


def parse_circle_equation(equation, p=1):
    eq = equation.replace('p', str(p))
    eq_nospace = eq.replace(' ', '')
    pat = r'\(\s*x\s*([-+])\s*(\d+(\.\d+)?)\)\*\*2\+\(\s*y\s*([-+])\s*(\d+(\.\d+)?)\)\*\*2=(\d+(\.\d+)?)'
    match = re.fullmatch(pat, eq_nospace)
    if match:
        sx, xval, _, sy, yval, _, r2, _ = match.groups()
        xc = float(xval) * (-1 if sx == '-' else 1)
        yc = float(yval) * (-1 if sy == '-' else 1)
        r = float(r2) ** 0.5
        return ('circle', xc, yc, r)
    match = re.fullmatch(r'x\*\*2\+y\*\*2=(\d+(\.\d+)?)', eq_nospace)
    if match:
        r2 = float(match.group(1))
        return ('circle', 0.0, 0.0, r2 ** 0.5)
    return None


def parse_square_equation(equation, p=1):
    eq = equation.replace('p', str(p))
    eq_str = eq.replace(' ', '')
    pat = r'abs\(x([-\+]\d+(\.\d+)?)\)<=([\d\.]+)andabs\(y([-\+]\d+(\.\d+)?)\)<=([\d\.]+)'
    match = re.fullmatch(pat, eq_str)
    if match:
        x_shift, _, size_x, y_shift, _, size_y = match.groups()
        xc = -float(x_shift)
        yc = -float(y_shift)
        lx = float(size_x) * 2
        ly = float(size_y) * 2
        return ('square', xc, yc, lx, ly)
    match = re.fullmatch(r'abs\(x\)<=([\d\.]+)andabs\(y\)<=([\d\.]+)', eq_str)
    if match:
        lx, ly = map(lambda s: float(s) * 2, match.groups())
        return ('square', 0.0, 0.0, lx, ly)
    return None


def parse_line_equation(equation, p=1):
    eq = equation.replace('p', str(p)).replace(' ', '')
    match_x = re.fullmatch(r'x=([-+]?\d+(\.\d+)?)', eq)
    if match_x:
        val = float(match_x.group(1))
        return ('vertical', val)
    match_y = re.fullmatch(r'y=([-+]?\d+(\.\d+)?)', eq)
    if match_y:
        val = float(match_y.group(1))
        return ('horizontal', val)
    return None


_ALLOWED_GLOBALS = {
    "np": np,
    "sin": np.sin, "cos": np.cos, "tan": np.tan,
    "arcsin": np.arcsin, "arccos": np.arccos, "arctan": np.arctan,
    "sinh": np.sinh, "cosh": np.cosh, "tanh": np.tanh,
    "exp": np.exp, "log": np.log, "log10": np.log10,
    "sqrt": np.sqrt, "abs": np.abs, "pi": np.pi, "e": np.e, "math": math
}


def _safe_eval(expr, local_vars):
    return eval(expr, {**_ALLOWED_GLOBALS}, local_vars)


def _prepare_y_from_eval(y_raw, x):
    if np.isscalar(y_raw):
        return np.full_like(x, y_raw, dtype=float)
    y_arr = np.asarray(y_raw)
    if y_arr.shape == x.shape:
        return y_arr
    try:
        return np.broadcast_to(y_arr, x.shape)
    except Exception:
        if y_arr.size == 1:
            return np.full_like(x, float(y_arr.ravel()[0]), dtype=float)
        raise ValueError(f"Невозможно привести результат выражения к форме x: {x.shape}, получено: {y_arr.shape}")


def plot_object(ax, inp, p=1, color=None):
    result = parse_circle_equation(inp, p)
    if result:
        _, xc, yc, r = result
        t = np.linspace(0, 2 * np.pi, 400)
        x = xc + r * np.cos(t)
        y = yc + r * np.sin(t)
        ax.plot(x, y, color=color)
        ax.set_aspect('equal')
        return
    result = parse_square_equation(inp, p)
    if result:
        _, xc, yc, lx, ly = result
        x_ = np.array([xc - lx / 2, xc + lx / 2, xc + lx / 2, xc - lx / 2, xc - lx / 2], dtype=float)
        y_ = np.array([yc - ly / 2, yc - ly / 2, yc + ly / 2, yc + ly / 2, yc - ly / 2], dtype=float)
        ax.plot(x_, y_, color=color)
        ax.set_aspect('equal')
        return
    result = parse_line_equation(inp, p)
    if result:
        t, val = result
        if t == 'vertical':
            y = np.linspace(-10, 10, 1000)
            x = np.ones_like(y) * val
            ax.plot(x, y, color=color)
        else:
            x = np.linspace(-10, 10, 1000)
            y = np.ones_like(x) * val
            ax.plot(x, y, color=color)
        return
    x = np.linspace(-10, 10, 1000)
    expr_for_eval = inp.replace('p', f'({p})')
    depends_on_x = 'x' in re.sub(r'\s+', '', expr_for_eval)
    try:
        y_raw = _safe_eval(expr_for_eval, {"x": x, "p": p})
        y = _prepare_y_from_eval(y_raw, x) if depends_on_x or not np.isscalar(y_raw) else np.full_like(x, y_raw, dtype=float)
        ax.plot(x, y, color=color)
    except Exception as e:
        raise RuntimeError(f"Ошибка при вычислении выражения '{inp}' при p={p}: {e}")


def ask_graph_input(order_text):
    print(f"\n{order_text} (окружность, квадрат, прямая x=.../y=..., или y=f(x), можно с p):")
    return input("> ").strip()

def ask_p_params():
    p_min = float(input("Минимум p: "))
    p_max = float(input("Максимум p: "))
    n = int(input("Сколько графиков на оси: "))
    return p_min, p_max, n


def main():
    try:
        fig, ax = plt.subplots(figsize=(8, 8))
        inp1 = ask_graph_input("Введите основной график")
        if has_parameter_p(inp1):
            p_min, p_max, n = ask_p_params()
            p_values = np.linspace(p_min, p_max, n)
            for i, p_val in enumerate(p_values):
                plot_object(ax, inp1, p_val, color=f"C{i % 10}")
        else:
            plot_object(ax, inp1, color="C0")
        add_second = input("\nДобавить второй график на оси? (да/нет): ").strip().lower()
        if add_second in ("да", "yes", "y"):
            inp2 = ask_graph_input("Введите второй график")
            if has_parameter_p(inp2):
                p_min, p_max, n = ask_p_params()
                p_values = np.linspace(p_min, p_max, n)
                for i, p_val in enumerate(p_values):
                    plot_object(ax, inp2, p_val, color=f"C{(i + 3) % 10}")
            else:
                plot_object(ax, inp2, color="C1")
        beautify_axes(ax)
        print("\nГрафик готов. Закройте окно графика для выхода.")
        plt.show()
    except Exception as e:
        print("\nОшибка:", e)

if __name__ == "__main__":
    main()
